C51 COMPILER V9.60.0.0   RTC_DRIVER                                                        02/27/2023 00:53:29 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE RTC_DRIVER
OBJECT MODULE PLACED IN .\src\rtc_driver.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\elass\S
                    -implicityStudio\v5_workspace\lamp_2\src\rtc_driver.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY
                    -(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\elass\SimplicityStudio\v5_workspace\
                    -lamp_2\inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.5//Device/shared/si8051Base;C:/SiliconLabs/Simpli
                    -cityStudio/v5/developer/sdks/8051/v4.2.5//Device/EFM8BB52/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.
                    -2.5//Device/EFM8BB52/peripheral_driver/inc) REGFILE(lamp_2.ORC) PRINT(.\src\rtc_driver.lst) COND PAGEWIDTH(120) PAGELENG
                    -TH(65) OBJECT(.\src\rtc_driver.OBJ)

line level    source

   1          
   2          #include <SI_EFM8BB52_Register_Enums.h>
   3          #include "smb_0.h"
   4          #include "rtc_driver.h"
   5          
   6          
   7          
   8          static SI_SEGMENT_VARIABLE(rtc_send_buffer[RTC_SEND_BUFFER_SIZE], uint8_t, SI_SEG_XDATA);
   9          static SI_SEGMENT_VARIABLE(rtc_receive_buffer[RTC_RECEIVE_BUFFER_SIZE], uint8_t, SI_SEG_XDATA);
  10          
  11          
  12          
  13          static xdata rtc_time_data rtc_data;
  14          
  15          bool transfer_complete = false;
  16          
  17          //We need to tell our main thread to continue when transfer complete.
  18          void SMB0_transferCompleteCb()
  19          {
  20   1        transfer_complete = true;
  21   1      }
  22          
  23          void SMB0_errorCb(SMB0_TransferError_t error){
  24   1        transfer_complete = true;
  25   1      }
*** WARNING C280 IN LINE 23 OF C:\Users\elass\SimplicityStudio\v5_workspace\lamp_2\src\rtc_driver.c: 'error': unreferenc
             -ed local variable
  26          
  27          
  28          void SMB0_commandReceivedCb(){
  29   1      
  30   1      }
  31          
  32          // Send clock pulses to the RTC module to reset its i2c interface
  33          void rtc_reset(){
  34   1        uint8_t i;
  35   1        // Disable SMB0's access to the pins
  36   1        XBR2 &= ~XBR2_XBARE__BMASK; // disable crossbar
  37   1        SCL_PnSKIP |= SCL_PnSKIP_Bm__BMASK; // skip SCL pin
  38   1        SDA_PnSKIP |= SDA_PnSKIP_Bm__BMASK; // skip SDA pin
  39   1        SCL_PnMDIN |= SCL_PnMDIN_Bm__BMASK; // put SCL pin into digital mode
  40   1        SDA_PnMDIN |= SDA_PnMDIN_Bm__BMASK; // put SDA pin into digital mode
  41   1        XBR0 &= ~XBR0_SMB0E__BMASK; // Disable SMB0 crossbar access
  42   1        XBR2 |= XBR2_XBARE__BMASK; // enable crossbar
  43   1      
  44   1        // Send clock pulses till the SDA line is allowed to go up
  45   1        while(!SDA_PnBm){
  46   2            SCL_PnBm = 0;
  47   2            for(i=0; i < 0xFF; i++);
  48   2            SCL_PnBm = 1;
C51 COMPILER V9.60.0.0   RTC_DRIVER                                                        02/27/2023 00:53:29 PAGE 2   

  49   2            for(i=0; i < 0xFF; i++);
  50   2        }
  51   1        // Reenable SMB0's access to the pins
  52   1        XBR2 &= ~XBR2_XBARE__BMASK; // disable crossbar
  53   1        SCL_PnSKIP &= ~SCL_PnSKIP_Bm__BMASK; // unskip SCL pin
  54   1        SDA_PnSKIP &= ~SDA_PnSKIP_Bm__BMASK; // unskip SDA pin
  55   1        XBR0 |= XBR0_SMB0E__BMASK; // enable SMB0 crossbar access
  56   1        XBR2 |= XBR2_XBARE__BMASK; // enable crossbar
  57   1      }
  58          
  59          
  60          
  61          // Convert 8-bit binary numbers from bcd to hex format
  62          static uint8_t BCD_to_HEX(uint8_t number)
  63          {
  64   1        return (number / 0x10) *10  + (number % 0x10);
  65   1      }
  66          
  67          // Convert 8-bit binary numbers from bcd to hex format
  68          static uint8_t HEX_TO_BCD(uint8_t number)
  69          {
  70   1        return (number/10)*0x10 + (number % 10);
  71   1      }
  72          
  73          void upload_time_to_RTC(){
  74   1        uint8_t i;
  75   1      
  76   1        // Clear send buffer
  77   1        for(i = 0; i < RTC_SEND_BUFFER_SIZE; i++)
  78   1            rtc_send_buffer[i] = 0;
  79   1      
  80   1      
  81   1        // Write date-time to RTC send buffer
  82   1        rtc_send_buffer[0] = 0x00; // Target starting register address
  83   1        rtc_send_buffer[RTC_SECONDS_REG+1] = HEX_TO_BCD(rtc_data.seconds);
  84   1        rtc_send_buffer[RTC_MINUTES_REG+1] = HEX_TO_BCD(rtc_data.minutes);
  85   1        rtc_send_buffer[RTC_HOURS_REG+1] = HEX_TO_BCD(rtc_data.hours);
  86   1        rtc_send_buffer[RTC_DATE_REG+1] = HEX_TO_BCD(rtc_data.date);
  87   1        rtc_send_buffer[RTC_MONTH_REG+1] = HEX_TO_BCD(rtc_data.month);
  88   1        rtc_send_buffer[RTC_YEAR_REG+1] = HEX_TO_BCD(rtc_data.year);
  89   1        // Alarm and day of week registers are set to 0x00 as they are irrelevant
  90   1        // Control register is set to 0x00 for 1Hz cycle on SQW pin
  91   1        // Status register is set to 0x00 to clear OSF bit
  92   1        // Aging offset register is set to 0x00 to have normal operation
  93   1      
  94   1        // Write send buffer to RTC module
  95   1        transfer_complete = false;
  96   1        SMB0_transfer(RTC_DEVICE_ADDRESS << 1, rtc_send_buffer, NULL, RTC_SEND_BUFFER_SIZE, 0);
  97   1      
  98   1        // Wait for transfer to end
  99   1        while(!transfer_complete);
 100   1      }
 101          
 102          
 103          void read_time_from_RTC(){
 104   1        uint8_t pm;
 105   1      
 106   1      
 107   1        // Read data from RTC module
 108   1        transfer_complete = false;
 109   1        rtc_send_buffer[0] = 0x00;
 110   1        SMB0_transfer(RTC_DEVICE_ADDRESS << 1, rtc_send_buffer, rtc_receive_buffer, 1, RTC_RECEIVE_BUFFER_SIZE);
 111   1      
C51 COMPILER V9.60.0.0   RTC_DRIVER                                                        02/27/2023 00:53:29 PAGE 3   

 112   1        // Wait for transfer to end
 113   1        while(!transfer_complete);
 114   1      
 115   1        rtc_data.seconds = BCD_to_HEX(rtc_receive_buffer[RTC_SECONDS_REG] & RTC_SECONDS_MASK);
 116   1        rtc_data.minutes = BCD_to_HEX(rtc_receive_buffer[RTC_MINUTES_REG] & RTC_MINUTES_MASK);
 117   1      
 118   1        rtc_data.hours = rtc_receive_buffer[RTC_HOURS_REG] & 0x7F;
 119   1      
 120   1        // 12 hours mode
 121   1        if(rtc_data.hours & RTC_HOURS_REG_MODE_BIT__BMASK){
 122   2            pm = rtc_data.hours & RTC_HOURS_REG_PM_BIT__BMASK;
 123   2            rtc_data.hours = BCD_to_HEX(rtc_data.hours & RTC_HOURS12_MASK);
 124   2      
 125   2            if(rtc_data.hours == 12)
 126   2              {
 127   3                if(!pm)
 128   3                    rtc_data.hours = 0; // 12AM is 00
 129   3              }
 130   2      
 131   2            else if(pm)
 132   2                rtc_data.hours += 12;
 133   2        }
 134   1        // 24 hour mode
 135   1        else
 136   1            rtc_data.hours = BCD_to_HEX(rtc_data.hours & RTC_HOURS24_MASK);
 137   1      
 138   1        rtc_data.date = BCD_to_HEX(rtc_receive_buffer[RTC_DATE_REG] & RTC_DATE_MASK);
 139   1        rtc_data.month = BCD_to_HEX(rtc_receive_buffer[RTC_MONTH_REG] & RTC_MONTH_MASK);
 140   1        rtc_data.year = BCD_to_HEX(rtc_receive_buffer[RTC_YEAR_REG]);
 141   1        rtc_data.invalid = rtc_receive_buffer[RTC_STATUS_REG] >> RTC_STATUS_REG_OSF__SHIFT;
 142   1      
 143   1        // If time is valid, enable SQW interrupt
 144   1        IE_EX0 = is_time_valid();
 145   1      }
 146          
 147          uint8_t code days_per_month[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
 148          
 149          static uint8_t days_of_month()
 150          {
 151   1        // If February and leap year, add one day to standard days of month
 152   1        if((rtc_data.month == 2) && (rtc_data.year % 4 == 0))
 153   1          return days_per_month[rtc_data.month-1]+1;
 154   1      
 155   1        return days_per_month[rtc_data.month-1];
 156   1      }
 157          
 158          
 159          bool is_time_valid(){
 160   1        return !rtc_data.invalid;
 161   1      }
 162          
 163          // SQW 1 Hz interrupt from RTC module
 164          SI_INTERRUPT (INT0_ISR, INT0_IRQn)
 165            {
 166   1          P1_B4 = !P1_B4;
 167   1      
 168   1          if(++rtc_data.seconds != 60)
 169   1            return;
 170   1      
 171   1          rtc_data.seconds = 0;
 172   1          if(++rtc_data.minutes != 60)
 173   1            return;
 174   1      
C51 COMPILER V9.60.0.0   RTC_DRIVER                                                        02/27/2023 00:53:29 PAGE 4   

 175   1          rtc_data.minutes = 0;
 176   1          if(++rtc_data.hours != 24)
 177   1            return;
 178   1      
 179   1          rtc_data.hours = 0;
 180   1          if(++rtc_data.date != days_of_month())
 181   1            return;
 182   1      
 183   1          rtc_data.date = 1;
 184   1          if(++rtc_data.month != 13)
 185   1            return;
 186   1      
 187   1          rtc_data.month = 1;
 188   1          rtc_data.year++;
 189   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    562    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =     42    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
