C51 COMPILER V9.60.0.0   RTC_DRIVER                                                        02/27/2023 07:49:15 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE RTC_DRIVER
OBJECT MODULE PLACED IN .\src\rtc_driver.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\elass\S
                    -implicityStudio\v5_workspace\lamp_2\src\rtc_driver.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZY
                    -(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\elass\SimplicityStudio\v5_workspace\
                    -lamp_2\inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.2.5//Device/shared/si8051Base;C:/SiliconLabs/Simpli
                    -cityStudio/v5/developer/sdks/8051/v4.2.5//Device/EFM8BB52/inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.
                    -2.5//Device/EFM8BB52/peripheral_driver/inc) REGFILE(lamp_2.ORC) PRINT(.\src\rtc_driver.lst) COND PAGEWIDTH(120) PAGELENG
                    -TH(65) OBJECT(.\src\rtc_driver.OBJ)

line level    source

   1          
   2          #include <SI_EFM8BB52_Register_Enums.h>
   3          #include "smb_0.h"
   4          #include "rtc_driver.h"
   5          
   6          
   7          
   8          static SI_SEGMENT_VARIABLE(rtc_send_buffer[RTC_SEND_BUFFER_SIZE], uint8_t, SI_SEG_XDATA);
   9          static SI_SEGMENT_VARIABLE(rtc_receive_buffer[RTC_RECEIVE_BUFFER_SIZE], uint8_t, SI_SEG_XDATA);
  10          
  11          
  12          // datetime struct
  13          static xdata rtc_time_data rtc_data;
  14          
  15          // Flag to indicate end of RTC transfer
  16          bool transfer_complete = false;
  17          
  18          // Communication with RTC done
  19          void SMB0_transferCompleteCb()
  20          {
  21   1        transfer_complete = true;
  22   1      }
  23          
  24          // Error during communication with RTC
  25          void SMB0_errorCb(SMB0_TransferError_t error){
  26   1        // Disable state machine and put lamp in red (to be implemented later)
  27   1      }
*** WARNING C280 IN LINE 25 OF C:\Users\elass\SimplicityStudio\v5_workspace\lamp_2\src\rtc_driver.c: 'error': unreferenc
             -ed local variable
  28          
  29          // For slave transmission (irrelevant as chip is master-only)
  30          void SMB0_commandReceivedCb(){
  31   1      
  32   1      }
  33          
  34          // Send clock pulses to the RTC module to reset its i2c interface
  35          void rtc_reset(){
  36   1        uint8_t i;
  37   1        // Disable SMB0's access to the pins
  38   1        XBR2 &= ~XBR2_XBARE__BMASK; // disable crossbar
  39   1        SCL_PnSKIP |= SCL_PnSKIP_Bm__BMASK; // skip SCL pin
  40   1        SDA_PnSKIP |= SDA_PnSKIP_Bm__BMASK; // skip SDA pin
  41   1        SCL_PnMDIN |= SCL_PnMDIN_Bm__BMASK; // put SCL pin into digital mode
  42   1        SDA_PnMDIN |= SDA_PnMDIN_Bm__BMASK; // put SDA pin into digital mode
  43   1        XBR0 &= ~XBR0_SMB0E__BMASK; // Disable SMB0 crossbar access
  44   1        XBR2 |= XBR2_XBARE__BMASK; // enable crossbar
  45   1      
  46   1        // Send clock pulses till the SDA line is allowed to go up
  47   1        while(!SDA_PnBm){
  48   2            SCL_PnBm = 0;
C51 COMPILER V9.60.0.0   RTC_DRIVER                                                        02/27/2023 07:49:15 PAGE 2   

  49   2            for(i=0; i < 0xFF; i++);
  50   2            SCL_PnBm = 1;
  51   2            for(i=0; i < 0xFF; i++);
  52   2        }
  53   1        // Reenable SMB0's access to the pins
  54   1        XBR2 &= ~XBR2_XBARE__BMASK; // disable crossbar
  55   1        SCL_PnSKIP &= ~SCL_PnSKIP_Bm__BMASK; // unskip SCL pin
  56   1        SDA_PnSKIP &= ~SDA_PnSKIP_Bm__BMASK; // unskip SDA pin
  57   1        XBR0 |= XBR0_SMB0E__BMASK; // enable SMB0 crossbar access
  58   1        XBR2 |= XBR2_XBARE__BMASK; // enable crossbar
  59   1      }
  60          
  61          
  62          
  63          // Convert 8-bit binary numbers from bcd to hex format
  64          static uint8_t BCD_to_HEX(uint8_t number)
  65          {
  66   1        return (number / 0x10) *10  + (number % 0x10);
  67   1      }
  68          
  69          // Convert 8-bit binary numbers from bcd to hex format
  70          static uint8_t HEX_TO_BCD(uint8_t number)
  71          {
  72   1        return (number/10)*0x10 + (number % 10);
  73   1      }
  74          
  75          void upload_time_to_RTC(){
  76   1        uint8_t i;
  77   1      
  78   1        // Clear send buffer
  79   1        for(i = 0; i < RTC_SEND_BUFFER_SIZE; i++)
  80   1            rtc_send_buffer[i] = 0;
  81   1      
  82   1      
  83   1        // Write date-time to RTC send buffer
  84   1        rtc_send_buffer[0] = 0x00; // Target starting register address
  85   1        rtc_send_buffer[RTC_SECONDS_REG+1] = HEX_TO_BCD(rtc_data.seconds);
  86   1        rtc_send_buffer[RTC_MINUTES_REG+1] = HEX_TO_BCD(rtc_data.minutes);
  87   1        rtc_send_buffer[RTC_HOURS_REG+1] = HEX_TO_BCD(rtc_data.hours);
  88   1        rtc_send_buffer[RTC_DATE_REG+1] = HEX_TO_BCD(rtc_data.date);
  89   1        rtc_send_buffer[RTC_MONTH_REG+1] = HEX_TO_BCD(rtc_data.month);
  90   1        rtc_send_buffer[RTC_YEAR_REG+1] = HEX_TO_BCD(rtc_data.year);
  91   1        // Alarm and day of week registers are set to 0x00 as they are irrelevant
  92   1        // Control register is set to 0x00 for 1Hz cycle on SQW pin
  93   1        // Status register is set to 0x00 to clear OSF bit
  94   1        // Aging offset register is set to 0x00 to have normal operation
  95   1      
  96   1        // Write send buffer to RTC module
  97   1        transfer_complete = false;
  98   1        SMB0_transfer(RTC_DEVICE_ADDRESS << 1, rtc_send_buffer, NULL, RTC_SEND_BUFFER_SIZE, 0);
  99   1      
 100   1        // Wait for transfer to end
 101   1        while(!transfer_complete);
 102   1      }
 103          
 104          
 105          void read_time_from_RTC(){
 106   1        uint8_t pm;
 107   1      
 108   1      
 109   1        // Read data from RTC module
 110   1        transfer_complete = false;
 111   1        rtc_send_buffer[0] = 0x00;
C51 COMPILER V9.60.0.0   RTC_DRIVER                                                        02/27/2023 07:49:15 PAGE 3   

 112   1        SMB0_transfer(RTC_DEVICE_ADDRESS << 1, rtc_send_buffer, rtc_receive_buffer, 1, RTC_RECEIVE_BUFFER_SIZE);
 113   1      
 114   1        // Wait for transfer to end
 115   1        while(!transfer_complete);
 116   1      
 117   1        rtc_data.seconds = BCD_to_HEX(rtc_receive_buffer[RTC_SECONDS_REG]);
 118   1        rtc_data.minutes = BCD_to_HEX(rtc_receive_buffer[RTC_MINUTES_REG]);
 119   1        rtc_data.hours = BCD_to_HEX(rtc_receive_buffer[RTC_HOURS_REG]);
 120   1        rtc_data.date = BCD_to_HEX(rtc_receive_buffer[RTC_DATE_REG]);
 121   1        rtc_data.month = BCD_to_HEX(rtc_receive_buffer[RTC_MONTH_REG]);
 122   1        rtc_data.year = BCD_to_HEX(rtc_receive_buffer[RTC_YEAR_REG]);
 123   1        rtc_data.invalid = rtc_receive_buffer[RTC_STATUS_REG] >> RTC_STATUS_REG_OSF__SHIFT;
 124   1      
 125   1        // If time is valid, enable SQW INT0 interrupt to keep up with time
 126   1        IE_EX0 = is_time_valid();
 127   1      }
*** WARNING C280 IN LINE 106 OF C:\Users\elass\SimplicityStudio\v5_workspace\lamp_2\src\rtc_driver.c: 'pm': unreferenced
             - local variable
 128          
 129          uint8_t code days_per_month[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
 130          
 131          static uint8_t days_of_month()
 132          {
 133   1        // If February and leap year, add one day to standard days of month
 134   1        if((rtc_data.month == 2) && (rtc_data.year % 4 == 0))
 135   1          return days_per_month[rtc_data.month-1]+1;
 136   1      
 137   1        return days_per_month[rtc_data.month-1];
 138   1      }
 139          
 140          
 141          bool is_time_valid(){
 142   1        return !rtc_data.invalid;
 143   1      }
 144          
 145          // SQW 1 Hz interrupt from RTC module to update datetime
 146          SI_INTERRUPT (INT0_ISR, INT0_IRQn)
 147            {
 148   1          // Blink led (for visual debugging purposes, will be removed)
 149   1          P1_B4 = !P1_B4;
 150   1      
 151   1          // Update datetime (trickle down modification)
 152   1      
 153   1          if(++rtc_data.seconds != 60)
 154   1            return;
 155   1      
 156   1          rtc_data.seconds = 0;
 157   1          if(++rtc_data.minutes != 60)
 158   1            return;
 159   1      
 160   1          rtc_data.minutes = 0;
 161   1          if(++rtc_data.hours != 24)
 162   1            return;
 163   1      
 164   1          rtc_data.hours = 0;
 165   1          if(++rtc_data.date != days_of_month())
 166   1            return;
 167   1      
 168   1          rtc_data.date = 1;
 169   1          if(++rtc_data.month != 13)
 170   1            return;
 171   1      
 172   1          rtc_data.month = 1;
C51 COMPILER V9.60.0.0   RTC_DRIVER                                                        02/27/2023 07:49:15 PAGE 4   

 173   1          rtc_data.year++;
 174   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    504    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =     42    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
